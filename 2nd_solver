import tensorflow as tf

class SecondOrderDSGESolver:
    def __init__(self,
                 # First-order derivatives (batch, n_eq, ...)
                 H_x, H_y,
                 H_xprime, H_yprime,
                 
                 # Second-order derivatives (batch, n_eq, ...)
                 H_xx, H_xy, H_yy,
                 H_xprimex, H_xprimey, H_xprimexprime,
                 H_yprimex, H_yprimey, H_yprimexprime,
                 
                 # First-order solution components
                 h_x,  # (batch, n_x, n_x)
                 g_x): # (batch, n_y, n_x)
        """Initializes second-order DSGE solver with model derivatives.
        
        Args:
            H_*: Model derivatives from equilibrium conditions
            h_x: First-order state transition matrix
            g_x: First-order decision rule matrix
        """
        # Store derivatives
        self.H_x, self.H_y = H_x, H_y
        self.H_xprime, self.H_yprime = H_xprime, H_yprime
        self.H_xx, self.H_xy, self.H_yy = H_xx, H_xy, H_yy
        self.H_xprimex, self.H_xprimey = H_xprimex, H_xprimey
        self.H_xprimexprime = H_xprimexprime
        self.H_yprimex, self.H_yprimey = H_yprimex, H_yprimey
        self.H_yprimexprime = H_yprimexprime
        
        # Store first-order solutions
        self.h_x = h_x
        self.g_x = g_x
        
        # Dimensions
        self.batch_size = tf.shape(H_x)[0]
        self.n_eq = H_x.shape[1]  # Number of equations
        self.n_x = h_x.shape[-1]  # Number of state variables
        self.n_y = g_x.shape[-2]  # Number of control variables
        
    def compute_second_order(self):
        """Main entry point: computes all second-order coefficients.
        
        Returns:
            Dictionary containing:
            - g_xx: (batch, n_y, n_x, n_x)
            - h_xx: (batch, n_x, n_x, n_x) 
            - g_σσ: (batch, n_y)
            - h_σσ: (batch, n_x)
        """
        g_xx, h_xx = self._solve_gxx_hxx()
        g_ss, h_ss = self._solve_gss_hss(g_xx, h_xx)
        
        return {
            'g_xx': g_xx,
            'h_xx': h_xx,
            'g_σσ': g_ss,
            'h_σσ': h_ss,
            # Cross terms are zero as shown in derivation
            'g_xσ': tf.zeros_like(g_xx[..., 0]),
            'h_xσ': tf.zeros_like(h_xx[..., 0])
        }

    def _solve_gxx_hxx(self):
        """Solves linear system for g_xx and h_xx coefficients."""
        # Construct coefficient matrix A (batch, n_eq*n_x², (n_y + n_x)*n_x²)
        A = self._build_gxx_coefficient_matrix()
        
        # Construct constant term C (batch, n_eq*n_x², 1)
        C = self._build_gxx_constant_term()
        
        # Solve linear system AX = -C
        X = tf.linalg.solve(A, -C)
        
        # Split and reshape solution
        g_xx = tf.reshape(X[..., :self.n_y*self.n_x**2, 0],
                         [self.batch_size, self.n_y, self.n_x, self.n_x])
        h_xx = tf.reshape(X[..., self.n_y*self.n_x**2:, 0],
                         [self.batch_size, self.n_x, self.n_x, self.n_x])
        return g_xx, h_xx

    def _build_gxx_coefficient_matrix(self):
        """Constructs coefficient matrix for g_xx/h_xx system."""
        # Term 1: H_y (I ⊗ h_xᵀ ⊗ h_xᵀ)
        term1 = tf.einsum('bij,bkl->bikjl', self.H_y, 
                         tf.eye(self.n_x, batch_shape=[self.batch_size]))
        term1 = tf.reshape(term1, [self.batch_size, self.n_eq*self.n_x**2, 
                                  self.n_y*self.n_x**2])
        
        # Term 2: [H_y' g_x + H_x'] (I ⊗ h_xᵀ)
        term2_base = tf.einsum('bijk,bkl->bijl', self.H_yprime, self.g_x) + self.H_xprime
        term2 = tf.einsum('bijk,bklm->bijlm', term2_base,
                         tf.eye(self.n_x, batch_shape=[self.batch_size]))
        term2 = tf.reshape(term2, [self.batch_size, self.n_eq*self.n_x**2,
                                  self.n_x*self.n_x**2])
        
        return tf.concat([term1, term2], axis=-1)

    def _build_gxx_constant_term(self):
        """Constructs constant term for g_xx/h_xx system."""
        # Term 1: H_y'y' g_x h_x ⊗ g_x h_x
        term1 = tf.einsum('bijk,bkl,bmn->bijnlm', self.H_yprimey, self.g_x, self.h_x)
        term1 = tf.einsum('bijnlm,bjpo->bipolm', term1, self.g_x @ self.h_x)
        
        # Term 2: H_y'x' g_x h_x ⊗ h_x
        term2 = tf.einsum('bijk,bkl,bmn->bijnlm', self.H_yprimex, self.g_x, self.h_x)
        term2 = tf.einsum('bijnlm,bjpo->bipolm', term2, self.h_x)
        
        # Term 3: H_yy g_x ⊗ g_x
        term3 = tf.einsum('bijk,bkl,bmn->bijlm', self.H_yy, self.g_x, self.g_x)
        
        # Term 4: H_x'x' h_x ⊗ h_x
        term4 = tf.einsum('bijk,bkl,bmn->bijlm', self.H_xprimexprime, self.h_x, self.h_x)
        
        # Combine terms and vectorize
        C = term1 + term2 + term3 + term4
        return tf.reshape(C, [self.batch_size, self.n_eq*self.n_x**2, 1])

    def _solve_gss_hss(self, g_xx, h_xx):
        """Solves linear system for g_σσ and h_σσ coefficients."""
        # Construct coefficient matrix (batch, n_eq, n_y + n_x)
        A = tf.concat([
            self.H_y + self.H_yprime,
            tf.einsum('bijk,bkl->bijl', self.H_yprime, self.g_x) + self.H_xprime
        ], axis=-1)
        
        # Construct constant term B (batch, n_eq, 1)
        B = self._build_gss_constant_term(g_xx, h_xx)
        
        # Solve linear system
        X = tf.linalg.solve(A, -B)
        
        # Split solution
        g_ss = X[..., :self.n_y, 0]
        h_ss = X[..., self.n_y:, 0]
        return g_ss, h_ss

    def _build_gss_constant_term(self, g_xx, h_xx):
        """Constructs constant term for σσ system."""
        # Term 1: H_y'y' g_x η Σ ηᵀ g_xᵀ
        term1 = tf.einsum('bijk,bkl,bmn,bno->bijo', 
                         self.H_yprimey, self.g_x, self.g_x, self.g_x)
        
        # Term 2: H_y'x' g_x η Σ ηᵀ
        term2 = tf.einsum('bijk,bkl,bmn->bijm', 
                         self.H_yprimex, self.g_x, self.g_x)
        
        # Term 3: H_y g_xx
        term3 = tf.einsum('bijk,bjklm->bilm', 
                         self.H_y, g_xx)
        
        # Term 4: H_x'x' η Σ ηᵀ
        term4 = tf.einsum('bijk,bkl,bmn->bijm', 
                         self.H_xprimexprime, self.g_x, self.g_x)
        
        # Sum all terms
        B = term1 + term2 + term3 + term4
        return tf.expand_dims(B, -1)
